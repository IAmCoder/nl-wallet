// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.7.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -580739876;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__full__accept_disclosure_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "accept_disclosure",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                    let output_ok = crate::api::full::accept_disclosure(api_pin)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__accept_pid_issuance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "accept_pid_issuance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                    let output_ok = crate::api::full::accept_pid_issuance(api_pin)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__cancel_disclosure_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_disclosure",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::cancel_disclosure().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__cancel_pid_issuance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_pid_issuance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::cancel_pid_issuance().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__change_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_old_pin = <String>::sse_decode(&mut deserializer);
            let api_new_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::change_pin(api_old_pin, api_new_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__check_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::check_pin(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_cards_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_cards_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_cards_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_configuration_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_configuration_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_configuration_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_lock_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_lock_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_lock_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_recent_history_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_recent_history_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_recent_history_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_version_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_version_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_version_state_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__continue_change_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "continue_change_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::continue_change_pin(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__continue_pid_issuance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "continue_pid_issuance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_uri = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::continue_pid_issuance(api_uri).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__create_pid_issuance_redirect_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_pid_issuance_redirect_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::create_pid_issuance_redirect_uri().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__get_history_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::get_history().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__get_history_for_card_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_history_for_card",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_doc_type = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::get_history_for_card(api_doc_type).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__get_version_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_version_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::full::get_version_string())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__has_active_disclosure_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_active_disclosure_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::has_active_disclosure_session().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__has_active_pid_issuance_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_active_pid_issuance_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::has_active_pid_issuance_session().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__has_registration_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_registration",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(crate::api::full::has_registration().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__identify_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "identify_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_uri = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::identify_uri(api_uri).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::init().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__is_biometric_unlock_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_biometric_unlock_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::is_biometric_unlock_enabled().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__is_initialized_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_initialized",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::full::is_initialized())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__is_valid_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_valid_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                    let output_ok = crate::api::full::is_valid_pin(api_pin)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__lock_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lock_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::lock_wallet().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__register_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "register",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::register(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__reset_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::reset_wallet().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_biometric_unlock_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_biometric_unlock",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_enable = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::set_biometric_unlock(api_enable).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_cards_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_cards_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink =
                <StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::set_cards_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_configuration_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_configuration_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::models::config::FlutterConfiguration,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::set_configuration_stream(api_sink).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_lock_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_lock_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink =
                <StreamSink<bool, flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::set_lock_stream(api_sink).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_recent_history_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_recent_history_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                Vec<crate::models::wallet_event::WalletEvent>,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::set_recent_history_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_version_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_version_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::models::version_state::FlutterVersionState,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::set_version_state_stream(api_sink).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__start_disclosure_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_disclosure",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_uri = <String>::sse_decode(&mut deserializer);
            let api_is_qr_code = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::start_disclosure(api_uri, api_is_qr_code).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__unlock_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unlock_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pin = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::unlock_wallet(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__unlock_wallet_with_biometrics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unlock_wallet_with_biometrics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_)
            };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::unlock_wallet_with_biometrics().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for StreamSink<bool, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::models::config::FlutterConfiguration, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::models::version_state::FlutterVersionState, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<Vec<crate::models::wallet_event::WalletEvent>, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::models::disclosure::AcceptDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_returnUrl = <Option<String>>::sse_decode(deserializer);
                return crate::models::disclosure::AcceptDisclosureResult::Ok {
                    return_url: var_returnUrl,
                };
            }
            1 => {
                let mut var_error = <crate::models::instruction::WalletInstructionError>::sse_decode(deserializer);
                return crate::models::disclosure::AcceptDisclosureResult::InstructionError { error: var_error };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::card::Card {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_issuer = <crate::models::disclosure::Organization>::sse_decode(deserializer);
        let mut var_persistence = <crate::models::card::CardPersistence>::sse_decode(deserializer);
        let mut var_docType = <String>::sse_decode(deserializer);
        let mut var_attributes = <Vec<crate::models::card::CardAttribute>>::sse_decode(deserializer);
        return crate::models::card::Card {
            issuer: var_issuer,
            persistence: var_persistence,
            doc_type: var_docType,
            attributes: var_attributes,
        };
    }
}

impl SseDecode for crate::models::card::CardAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_key = <String>::sse_decode(deserializer);
        let mut var_labels = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_value = <crate::models::card::CardValue>::sse_decode(deserializer);
        return crate::models::card::CardAttribute {
            key: var_key,
            labels: var_labels,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::card::CardPersistence {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::card::CardPersistence::InMemory;
            }
            1 => {
                let mut var_id = <String>::sse_decode(deserializer);
                return crate::models::card::CardPersistence::Stored { id: var_id };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::card::CardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::models::card::CardValue::String { value: var_value };
            }
            1 => {
                let mut var_value = <bool>::sse_decode(deserializer);
                return crate::models::card::CardValue::Boolean { value: var_value };
            }
            2 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::models::card::CardValue::Date { value: var_value };
            }
            3 => {
                let mut var_value = <crate::models::card::GenderCardValue>::sse_decode(deserializer);
                return crate::models::card::CardValue::Gender { value: var_value };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::disclosure::DisclosureCard {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_issuer = <crate::models::disclosure::Organization>::sse_decode(deserializer);
        let mut var_docType = <String>::sse_decode(deserializer);
        let mut var_attributes = <Vec<crate::models::card::CardAttribute>>::sse_decode(deserializer);
        return crate::models::disclosure::DisclosureCard {
            issuer: var_issuer,
            doc_type: var_docType,
            attributes: var_attributes,
        };
    }
}

impl SseDecode for crate::models::disclosure::DisclosureSessionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::disclosure::DisclosureSessionType::SameDevice,
            1 => crate::models::disclosure::DisclosureSessionType::CrossDevice,
            _ => unreachable!("Invalid variant for DisclosureSessionType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::DisclosureStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::disclosure::DisclosureStatus::Success,
            1 => crate::models::disclosure::DisclosureStatus::Cancelled,
            2 => crate::models::disclosure::DisclosureStatus::Error,
            _ => unreachable!("Invalid variant for DisclosureStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::DisclosureType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::disclosure::DisclosureType::Login,
            1 => crate::models::disclosure::DisclosureType::Regular,
            _ => unreachable!("Invalid variant for DisclosureType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::config::FlutterConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inactiveLockTimeout = <u16>::sse_decode(deserializer);
        let mut var_backgroundLockTimeout = <u16>::sse_decode(deserializer);
        let mut var_version = <u64>::sse_decode(deserializer);
        return crate::models::config::FlutterConfiguration {
            inactive_lock_timeout: var_inactiveLockTimeout,
            background_lock_timeout: var_backgroundLockTimeout,
            version: var_version,
        };
    }
}

impl SseDecode for crate::models::version_state::FlutterVersionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::version_state::FlutterVersionState::Ok;
            }
            1 => {
                return crate::models::version_state::FlutterVersionState::Notify;
            }
            2 => {
                return crate::models::version_state::FlutterVersionState::Recommend;
            }
            3 => {
                let mut var_expiresInSeconds = <u64>::sse_decode(deserializer);
                return crate::models::version_state::FlutterVersionState::Warn {
                    expires_in_seconds: var_expiresInSeconds,
                };
            }
            4 => {
                return crate::models::version_state::FlutterVersionState::Block;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::card::GenderCardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::card::GenderCardValue::Unknown,
            1 => crate::models::card::GenderCardValue::Male,
            2 => crate::models::card::GenderCardValue::Female,
            3 => crate::models::card::GenderCardValue::NotApplicable,
            _ => unreachable!("Invalid variant for GenderCardValue: {}", inner),
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::uri::IdentifyUriResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::uri::IdentifyUriResult::PidIssuance,
            1 => crate::models::uri::IdentifyUriResult::Disclosure,
            _ => unreachable!("Invalid variant for IdentifyUriResult: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::Image {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_xml = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Svg { xml: var_xml };
            }
            1 => {
                let mut var_base64 = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Png { base64: var_base64 };
            }
            2 => {
                let mut var_base64 = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Jpg { base64: var_base64 };
            }
            3 => {
                let mut var_path = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Asset { path: var_path };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for Vec<crate::models::card::Card> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::card::Card>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::card::CardAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::card::CardAttribute>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::disclosure::DisclosureCard> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::disclosure::DisclosureCard>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::card::LocalizedString> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::card::LocalizedString>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::disclosure::MissingAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::disclosure::MissingAttribute>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::wallet_event::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::wallet_event::WalletEvent>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::card::LocalizedString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_language = <String>::sse_decode(deserializer);
        let mut var_value = <String>::sse_decode(deserializer);
        return crate::models::card::LocalizedString {
            language: var_language,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::disclosure::MissingAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_labels = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        return crate::models::disclosure::MissingAttribute { labels: var_labels };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::disclosure::Image> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::disclosure::Image>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::disclosure::DisclosureCard>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::disclosure::DisclosureCard>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::card::LocalizedString>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::disclosure::Organization {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_legalName = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_displayName = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_description = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_image = <Option<crate::models::disclosure::Image>>::sse_decode(deserializer);
        let mut var_webUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_privacyPolicyUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_kvk = <Option<String>>::sse_decode(deserializer);
        let mut var_city = <Option<Vec<crate::models::card::LocalizedString>>>::sse_decode(deserializer);
        let mut var_category = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_department = <Option<Vec<crate::models::card::LocalizedString>>>::sse_decode(deserializer);
        let mut var_countryCode = <Option<String>>::sse_decode(deserializer);
        return crate::models::disclosure::Organization {
            legal_name: var_legalName,
            display_name: var_displayName,
            description: var_description,
            image: var_image,
            web_url: var_webUrl,
            privacy_policy_url: var_privacyPolicyUrl,
            kvk: var_kvk,
            city: var_city,
            category: var_category,
            department: var_department,
            country_code: var_countryCode,
        };
    }
}

impl SseDecode for crate::models::pin::PinValidationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::pin::PinValidationResult::Ok,
            1 => crate::models::pin::PinValidationResult::TooFewUniqueDigits,
            2 => crate::models::pin::PinValidationResult::SequentialDigits,
            3 => crate::models::pin::PinValidationResult::OtherIssue,
            _ => unreachable!("Invalid variant for PinValidationResult: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::RequestPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_dataStorageDurationInMinutes = <Option<u64>>::sse_decode(deserializer);
        let mut var_dataSharedWithThirdParties = <bool>::sse_decode(deserializer);
        let mut var_dataDeletionPossible = <bool>::sse_decode(deserializer);
        let mut var_policyUrl = <String>::sse_decode(deserializer);
        return crate::models::disclosure::RequestPolicy {
            data_storage_duration_in_minutes: var_dataStorageDurationInMinutes,
            data_shared_with_third_parties: var_dataSharedWithThirdParties,
            data_deletion_possible: var_dataDeletionPossible,
            policy_url: var_policyUrl,
        };
    }
}

impl SseDecode for crate::models::disclosure::StartDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_relyingParty = <crate::models::disclosure::Organization>::sse_decode(deserializer);
                let mut var_policy = <crate::models::disclosure::RequestPolicy>::sse_decode(deserializer);
                let mut var_requestedCards = <Vec<crate::models::disclosure::DisclosureCard>>::sse_decode(deserializer);
                let mut var_sharedDataWithRelyingPartyBefore = <bool>::sse_decode(deserializer);
                let mut var_sessionType = <crate::models::disclosure::DisclosureSessionType>::sse_decode(deserializer);
                let mut var_requestPurpose = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
                let mut var_requestOriginBaseUrl = <String>::sse_decode(deserializer);
                let mut var_requestType = <crate::models::disclosure::DisclosureType>::sse_decode(deserializer);
                return crate::models::disclosure::StartDisclosureResult::Request {
                    relying_party: var_relyingParty,
                    policy: var_policy,
                    requested_cards: var_requestedCards,
                    shared_data_with_relying_party_before: var_sharedDataWithRelyingPartyBefore,
                    session_type: var_sessionType,
                    request_purpose: var_requestPurpose,
                    request_origin_base_url: var_requestOriginBaseUrl,
                    request_type: var_requestType,
                };
            }
            1 => {
                let mut var_relyingParty = <crate::models::disclosure::Organization>::sse_decode(deserializer);
                let mut var_missingAttributes =
                    <Vec<crate::models::disclosure::MissingAttribute>>::sse_decode(deserializer);
                let mut var_sharedDataWithRelyingPartyBefore = <bool>::sse_decode(deserializer);
                let mut var_sessionType = <crate::models::disclosure::DisclosureSessionType>::sse_decode(deserializer);
                let mut var_requestPurpose = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
                let mut var_requestOriginBaseUrl = <String>::sse_decode(deserializer);
                return crate::models::disclosure::StartDisclosureResult::RequestAttributesMissing {
                    relying_party: var_relyingParty,
                    missing_attributes: var_missingAttributes,
                    shared_data_with_relying_party_before: var_sharedDataWithRelyingPartyBefore,
                    session_type: var_sessionType,
                    request_purpose: var_requestPurpose,
                    request_origin_base_url: var_requestOriginBaseUrl,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::models::wallet_event::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_dateTime = <String>::sse_decode(deserializer);
                let mut var_relyingParty = <crate::models::disclosure::Organization>::sse_decode(deserializer);
                let mut var_purpose = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
                let mut var_requestedCards =
                    <Option<Vec<crate::models::disclosure::DisclosureCard>>>::sse_decode(deserializer);
                let mut var_requestPolicy = <crate::models::disclosure::RequestPolicy>::sse_decode(deserializer);
                let mut var_status = <crate::models::disclosure::DisclosureStatus>::sse_decode(deserializer);
                let mut var_type = <crate::models::disclosure::DisclosureType>::sse_decode(deserializer);
                return crate::models::wallet_event::WalletEvent::Disclosure {
                    date_time: var_dateTime,
                    relying_party: var_relyingParty,
                    purpose: var_purpose,
                    requested_cards: var_requestedCards,
                    request_policy: var_requestPolicy,
                    status: var_status,
                    r#type: var_type,
                };
            }
            1 => {
                let mut var_dateTime = <String>::sse_decode(deserializer);
                let mut var_card = <crate::models::card::Card>::sse_decode(deserializer);
                return crate::models::wallet_event::WalletEvent::Issuance {
                    date_time: var_dateTime,
                    card: var_card,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::instruction::WalletInstructionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_attemptsLeftInRound = <u8>::sse_decode(deserializer);
                let mut var_isFinalRound = <bool>::sse_decode(deserializer);
                return crate::models::instruction::WalletInstructionError::IncorrectPin {
                    attempts_left_in_round: var_attemptsLeftInRound,
                    is_final_round: var_isFinalRound,
                };
            }
            1 => {
                let mut var_timeoutMillis = <u64>::sse_decode(deserializer);
                return crate::models::instruction::WalletInstructionError::Timeout {
                    timeout_millis: var_timeoutMillis,
                };
            }
            2 => {
                return crate::models::instruction::WalletInstructionError::Blocked;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::instruction::WalletInstructionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::instruction::WalletInstructionResult::Ok;
            }
            1 => {
                let mut var_error = <crate::models::instruction::WalletInstructionError>::sse_decode(deserializer);
                return crate::models::instruction::WalletInstructionResult::InstructionError { error: var_error };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__full__accept_disclosure_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__full__accept_pid_issuance_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__full__cancel_disclosure_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__full__cancel_pid_issuance_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__full__change_pin_impl(port, ptr, rust_vec_len, data_len),
        6 => wire__crate__api__full__check_pin_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__api__full__clear_cards_stream_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__full__clear_configuration_stream_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__full__clear_lock_stream_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__full__clear_recent_history_stream_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__full__clear_version_state_stream_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__full__continue_change_pin_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__full__continue_pid_issuance_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__full__create_pid_issuance_redirect_uri_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__api__full__get_history_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__full__get_history_for_card_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__full__get_version_string_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__api__full__has_active_disclosure_session_impl(port, ptr, rust_vec_len, data_len),
        19 => wire__crate__api__full__has_active_pid_issuance_session_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__full__has_registration_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__full__identify_uri_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__full__init_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__api__full__is_biometric_unlock_enabled_impl(port, ptr, rust_vec_len, data_len),
        24 => wire__crate__api__full__is_initialized_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__full__is_valid_pin_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__full__lock_wallet_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__full__register_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__full__reset_wallet_impl(port, ptr, rust_vec_len, data_len),
        29 => wire__crate__api__full__set_biometric_unlock_impl(port, ptr, rust_vec_len, data_len),
        30 => wire__crate__api__full__set_cards_stream_impl(port, ptr, rust_vec_len, data_len),
        31 => wire__crate__api__full__set_configuration_stream_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__full__set_lock_stream_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__api__full__set_recent_history_stream_impl(port, ptr, rust_vec_len, data_len),
        34 => wire__crate__api__full__set_version_state_stream_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__api__full__start_disclosure_impl(port, ptr, rust_vec_len, data_len),
        36 => wire__crate__api__full__unlock_wallet_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__full__unlock_wallet_with_biometrics_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::AcceptDisclosureResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::disclosure::AcceptDisclosureResult::Ok { return_url } => {
                [0.into_dart(), return_url.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::AcceptDisclosureResult::InstructionError { error } => {
                [1.into_dart(), error.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::AcceptDisclosureResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::AcceptDisclosureResult>
    for crate::models::disclosure::AcceptDisclosureResult
{
    fn into_into_dart(self) -> crate::models::disclosure::AcceptDisclosureResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::Card {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.issuer.into_into_dart().into_dart(),
            self.persistence.into_into_dart().into_dart(),
            self.doc_type.into_into_dart().into_dart(),
            self.attributes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::Card {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::Card> for crate::models::card::Card {
    fn into_into_dart(self) -> crate::models::card::Card {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::CardAttribute {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.key.into_into_dart().into_dart(),
            self.labels.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::CardAttribute {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::CardAttribute> for crate::models::card::CardAttribute {
    fn into_into_dart(self) -> crate::models::card::CardAttribute {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::CardPersistence {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::card::CardPersistence::InMemory => [0.into_dart()].into_dart(),
            crate::models::card::CardPersistence::Stored { id } => {
                [1.into_dart(), id.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::CardPersistence {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::CardPersistence> for crate::models::card::CardPersistence {
    fn into_into_dart(self) -> crate::models::card::CardPersistence {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::CardValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::card::CardValue::String { value } => {
                [0.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::models::card::CardValue::Boolean { value } => {
                [1.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::models::card::CardValue::Date { value } => {
                [2.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::models::card::CardValue::Gender { value } => {
                [3.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::CardValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::CardValue> for crate::models::card::CardValue {
    fn into_into_dart(self) -> crate::models::card::CardValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureCard {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.issuer.into_into_dart().into_dart(),
            self.doc_type.into_into_dart().into_dart(),
            self.attributes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureCard {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureCard>
    for crate::models::disclosure::DisclosureCard
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureCard {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureSessionType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SameDevice => 0.into_dart(),
            Self::CrossDevice => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureSessionType {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureSessionType>
    for crate::models::disclosure::DisclosureSessionType
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureSessionType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Success => 0.into_dart(),
            Self::Cancelled => 1.into_dart(),
            Self::Error => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureStatus {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureStatus>
    for crate::models::disclosure::DisclosureStatus
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Login => 0.into_dart(),
            Self::Regular => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureType {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureType>
    for crate::models::disclosure::DisclosureType
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::config::FlutterConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.inactive_lock_timeout.into_into_dart().into_dart(),
            self.background_lock_timeout.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::config::FlutterConfiguration {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::config::FlutterConfiguration>
    for crate::models::config::FlutterConfiguration
{
    fn into_into_dart(self) -> crate::models::config::FlutterConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::version_state::FlutterVersionState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::version_state::FlutterVersionState::Ok => [0.into_dart()].into_dart(),
            crate::models::version_state::FlutterVersionState::Notify => [1.into_dart()].into_dart(),
            crate::models::version_state::FlutterVersionState::Recommend => [2.into_dart()].into_dart(),
            crate::models::version_state::FlutterVersionState::Warn { expires_in_seconds } => {
                [3.into_dart(), expires_in_seconds.into_into_dart().into_dart()].into_dart()
            }
            crate::models::version_state::FlutterVersionState::Block => [4.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::version_state::FlutterVersionState {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::version_state::FlutterVersionState>
    for crate::models::version_state::FlutterVersionState
{
    fn into_into_dart(self) -> crate::models::version_state::FlutterVersionState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::GenderCardValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Unknown => 0.into_dart(),
            Self::Male => 1.into_dart(),
            Self::Female => 2.into_dart(),
            Self::NotApplicable => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::GenderCardValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::GenderCardValue> for crate::models::card::GenderCardValue {
    fn into_into_dart(self) -> crate::models::card::GenderCardValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::uri::IdentifyUriResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::PidIssuance => 0.into_dart(),
            Self::Disclosure => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::uri::IdentifyUriResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::uri::IdentifyUriResult>
    for crate::models::uri::IdentifyUriResult
{
    fn into_into_dart(self) -> crate::models::uri::IdentifyUriResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::Image {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::disclosure::Image::Svg { xml } => {
                [0.into_dart(), xml.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::Image::Png { base64 } => {
                [1.into_dart(), base64.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::Image::Jpg { base64 } => {
                [2.into_dart(), base64.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::Image::Asset { path } => {
                [3.into_dart(), path.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::Image {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::Image> for crate::models::disclosure::Image {
    fn into_into_dart(self) -> crate::models::disclosure::Image {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::LocalizedString {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.language.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::LocalizedString {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::LocalizedString> for crate::models::card::LocalizedString {
    fn into_into_dart(self) -> crate::models::card::LocalizedString {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::MissingAttribute {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.labels.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::MissingAttribute {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::MissingAttribute>
    for crate::models::disclosure::MissingAttribute
{
    fn into_into_dart(self) -> crate::models::disclosure::MissingAttribute {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::Organization {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.legal_name.into_into_dart().into_dart(),
            self.display_name.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.image.into_into_dart().into_dart(),
            self.web_url.into_into_dart().into_dart(),
            self.privacy_policy_url.into_into_dart().into_dart(),
            self.kvk.into_into_dart().into_dart(),
            self.city.into_into_dart().into_dart(),
            self.category.into_into_dart().into_dart(),
            self.department.into_into_dart().into_dart(),
            self.country_code.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::Organization {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::Organization>
    for crate::models::disclosure::Organization
{
    fn into_into_dart(self) -> crate::models::disclosure::Organization {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::pin::PinValidationResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Ok => 0.into_dart(),
            Self::TooFewUniqueDigits => 1.into_dart(),
            Self::SequentialDigits => 2.into_dart(),
            Self::OtherIssue => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::pin::PinValidationResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::pin::PinValidationResult>
    for crate::models::pin::PinValidationResult
{
    fn into_into_dart(self) -> crate::models::pin::PinValidationResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::RequestPolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.data_storage_duration_in_minutes.into_into_dart().into_dart(),
            self.data_shared_with_third_parties.into_into_dart().into_dart(),
            self.data_deletion_possible.into_into_dart().into_dart(),
            self.policy_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::RequestPolicy {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::RequestPolicy>
    for crate::models::disclosure::RequestPolicy
{
    fn into_into_dart(self) -> crate::models::disclosure::RequestPolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::StartDisclosureResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::disclosure::StartDisclosureResult::Request {
                relying_party,
                policy,
                requested_cards,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
                request_type,
            } => [
                0.into_dart(),
                relying_party.into_into_dart().into_dart(),
                policy.into_into_dart().into_dart(),
                requested_cards.into_into_dart().into_dart(),
                shared_data_with_relying_party_before.into_into_dart().into_dart(),
                session_type.into_into_dart().into_dart(),
                request_purpose.into_into_dart().into_dart(),
                request_origin_base_url.into_into_dart().into_dart(),
                request_type.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::disclosure::StartDisclosureResult::RequestAttributesMissing {
                relying_party,
                missing_attributes,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
            } => [
                1.into_dart(),
                relying_party.into_into_dart().into_dart(),
                missing_attributes.into_into_dart().into_dart(),
                shared_data_with_relying_party_before.into_into_dart().into_dart(),
                session_type.into_into_dart().into_dart(),
                request_purpose.into_into_dart().into_dart(),
                request_origin_base_url.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::StartDisclosureResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::StartDisclosureResult>
    for crate::models::disclosure::StartDisclosureResult
{
    fn into_into_dart(self) -> crate::models::disclosure::StartDisclosureResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::wallet_event::WalletEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::wallet_event::WalletEvent::Disclosure {
                date_time,
                relying_party,
                purpose,
                requested_cards,
                request_policy,
                status,
                r#type,
            } => [
                0.into_dart(),
                date_time.into_into_dart().into_dart(),
                relying_party.into_into_dart().into_dart(),
                purpose.into_into_dart().into_dart(),
                requested_cards.into_into_dart().into_dart(),
                request_policy.into_into_dart().into_dart(),
                status.into_into_dart().into_dart(),
                r#type.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::wallet_event::WalletEvent::Issuance { date_time, card } => [
                1.into_dart(),
                date_time.into_into_dart().into_dart(),
                card.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::wallet_event::WalletEvent {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::wallet_event::WalletEvent>
    for crate::models::wallet_event::WalletEvent
{
    fn into_into_dart(self) -> crate::models::wallet_event::WalletEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::instruction::WalletInstructionError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::instruction::WalletInstructionError::IncorrectPin {
                attempts_left_in_round,
                is_final_round,
            } => [
                0.into_dart(),
                attempts_left_in_round.into_into_dart().into_dart(),
                is_final_round.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::instruction::WalletInstructionError::Timeout { timeout_millis } => {
                [1.into_dart(), timeout_millis.into_into_dart().into_dart()].into_dart()
            }
            crate::models::instruction::WalletInstructionError::Blocked => [2.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::instruction::WalletInstructionError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::instruction::WalletInstructionError>
    for crate::models::instruction::WalletInstructionError
{
    fn into_into_dart(self) -> crate::models::instruction::WalletInstructionError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::instruction::WalletInstructionResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::instruction::WalletInstructionResult::Ok => [0.into_dart()].into_dart(),
            crate::models::instruction::WalletInstructionResult::InstructionError { error } => {
                [1.into_dart(), error.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::instruction::WalletInstructionResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::instruction::WalletInstructionResult>
    for crate::models::instruction::WalletInstructionResult
{
    fn into_into_dart(self) -> crate::models::instruction::WalletInstructionResult {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for StreamSink<bool, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::models::config::FlutterConfiguration, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::models::version_state::FlutterVersionState, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<Vec<crate::models::wallet_event::WalletEvent>, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::models::disclosure::AcceptDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::disclosure::AcceptDisclosureResult::Ok { return_url } => {
                <i32>::sse_encode(0, serializer);
                <Option<String>>::sse_encode(return_url, serializer);
            }
            crate::models::disclosure::AcceptDisclosureResult::InstructionError { error } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::instruction::WalletInstructionError>::sse_encode(error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::card::Card {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::disclosure::Organization>::sse_encode(self.issuer, serializer);
        <crate::models::card::CardPersistence>::sse_encode(self.persistence, serializer);
        <String>::sse_encode(self.doc_type, serializer);
        <Vec<crate::models::card::CardAttribute>>::sse_encode(self.attributes, serializer);
    }
}

impl SseEncode for crate::models::card::CardAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.key, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.labels, serializer);
        <crate::models::card::CardValue>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::card::CardPersistence {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::card::CardPersistence::InMemory => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::card::CardPersistence::Stored { id } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::card::CardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::card::CardValue::String { value } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(value, serializer);
            }
            crate::models::card::CardValue::Boolean { value } => {
                <i32>::sse_encode(1, serializer);
                <bool>::sse_encode(value, serializer);
            }
            crate::models::card::CardValue::Date { value } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(value, serializer);
            }
            crate::models::card::CardValue::Gender { value } => {
                <i32>::sse_encode(3, serializer);
                <crate::models::card::GenderCardValue>::sse_encode(value, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::disclosure::DisclosureCard {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::disclosure::Organization>::sse_encode(self.issuer, serializer);
        <String>::sse_encode(self.doc_type, serializer);
        <Vec<crate::models::card::CardAttribute>>::sse_encode(self.attributes, serializer);
    }
}

impl SseEncode for crate::models::disclosure::DisclosureSessionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::disclosure::DisclosureSessionType::SameDevice => 0,
                crate::models::disclosure::DisclosureSessionType::CrossDevice => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::DisclosureStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::disclosure::DisclosureStatus::Success => 0,
                crate::models::disclosure::DisclosureStatus::Cancelled => 1,
                crate::models::disclosure::DisclosureStatus::Error => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::DisclosureType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::disclosure::DisclosureType::Login => 0,
                crate::models::disclosure::DisclosureType::Regular => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::config::FlutterConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.inactive_lock_timeout, serializer);
        <u16>::sse_encode(self.background_lock_timeout, serializer);
        <u64>::sse_encode(self.version, serializer);
    }
}

impl SseEncode for crate::models::version_state::FlutterVersionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::version_state::FlutterVersionState::Ok => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::version_state::FlutterVersionState::Notify => {
                <i32>::sse_encode(1, serializer);
            }
            crate::models::version_state::FlutterVersionState::Recommend => {
                <i32>::sse_encode(2, serializer);
            }
            crate::models::version_state::FlutterVersionState::Warn { expires_in_seconds } => {
                <i32>::sse_encode(3, serializer);
                <u64>::sse_encode(expires_in_seconds, serializer);
            }
            crate::models::version_state::FlutterVersionState::Block => {
                <i32>::sse_encode(4, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::card::GenderCardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::card::GenderCardValue::Unknown => 0,
                crate::models::card::GenderCardValue::Male => 1,
                crate::models::card::GenderCardValue::Female => 2,
                crate::models::card::GenderCardValue::NotApplicable => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::uri::IdentifyUriResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::uri::IdentifyUriResult::PidIssuance => 0,
                crate::models::uri::IdentifyUriResult::Disclosure => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::Image {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::disclosure::Image::Svg { xml } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(xml, serializer);
            }
            crate::models::disclosure::Image::Png { base64 } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(base64, serializer);
            }
            crate::models::disclosure::Image::Jpg { base64 } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(base64, serializer);
            }
            crate::models::disclosure::Image::Asset { path } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(path, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for Vec<crate::models::card::Card> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::card::Card>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::card::CardAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::card::CardAttribute>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::disclosure::DisclosureCard> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::disclosure::DisclosureCard>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::card::LocalizedString> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::card::LocalizedString>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::disclosure::MissingAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::disclosure::MissingAttribute>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::wallet_event::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::wallet_event::WalletEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::card::LocalizedString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.language, serializer);
        <String>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::disclosure::MissingAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.labels, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::disclosure::Image> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::disclosure::Image>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::disclosure::DisclosureCard>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::disclosure::DisclosureCard>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::card::LocalizedString>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::card::LocalizedString>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::disclosure::Organization {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.legal_name, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.display_name, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.description, serializer);
        <Option<crate::models::disclosure::Image>>::sse_encode(self.image, serializer);
        <Option<String>>::sse_encode(self.web_url, serializer);
        <Option<String>>::sse_encode(self.privacy_policy_url, serializer);
        <Option<String>>::sse_encode(self.kvk, serializer);
        <Option<Vec<crate::models::card::LocalizedString>>>::sse_encode(self.city, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.category, serializer);
        <Option<Vec<crate::models::card::LocalizedString>>>::sse_encode(self.department, serializer);
        <Option<String>>::sse_encode(self.country_code, serializer);
    }
}

impl SseEncode for crate::models::pin::PinValidationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::pin::PinValidationResult::Ok => 0,
                crate::models::pin::PinValidationResult::TooFewUniqueDigits => 1,
                crate::models::pin::PinValidationResult::SequentialDigits => 2,
                crate::models::pin::PinValidationResult::OtherIssue => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::RequestPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.data_storage_duration_in_minutes, serializer);
        <bool>::sse_encode(self.data_shared_with_third_parties, serializer);
        <bool>::sse_encode(self.data_deletion_possible, serializer);
        <String>::sse_encode(self.policy_url, serializer);
    }
}

impl SseEncode for crate::models::disclosure::StartDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::disclosure::StartDisclosureResult::Request {
                relying_party,
                policy,
                requested_cards,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
                request_type,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::disclosure::Organization>::sse_encode(relying_party, serializer);
                <crate::models::disclosure::RequestPolicy>::sse_encode(policy, serializer);
                <Vec<crate::models::disclosure::DisclosureCard>>::sse_encode(requested_cards, serializer);
                <bool>::sse_encode(shared_data_with_relying_party_before, serializer);
                <crate::models::disclosure::DisclosureSessionType>::sse_encode(session_type, serializer);
                <Vec<crate::models::card::LocalizedString>>::sse_encode(request_purpose, serializer);
                <String>::sse_encode(request_origin_base_url, serializer);
                <crate::models::disclosure::DisclosureType>::sse_encode(request_type, serializer);
            }
            crate::models::disclosure::StartDisclosureResult::RequestAttributesMissing {
                relying_party,
                missing_attributes,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::disclosure::Organization>::sse_encode(relying_party, serializer);
                <Vec<crate::models::disclosure::MissingAttribute>>::sse_encode(missing_attributes, serializer);
                <bool>::sse_encode(shared_data_with_relying_party_before, serializer);
                <crate::models::disclosure::DisclosureSessionType>::sse_encode(session_type, serializer);
                <Vec<crate::models::card::LocalizedString>>::sse_encode(request_purpose, serializer);
                <String>::sse_encode(request_origin_base_url, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::wallet_event::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::wallet_event::WalletEvent::Disclosure {
                date_time,
                relying_party,
                purpose,
                requested_cards,
                request_policy,
                status,
                r#type,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(date_time, serializer);
                <crate::models::disclosure::Organization>::sse_encode(relying_party, serializer);
                <Vec<crate::models::card::LocalizedString>>::sse_encode(purpose, serializer);
                <Option<Vec<crate::models::disclosure::DisclosureCard>>>::sse_encode(requested_cards, serializer);
                <crate::models::disclosure::RequestPolicy>::sse_encode(request_policy, serializer);
                <crate::models::disclosure::DisclosureStatus>::sse_encode(status, serializer);
                <crate::models::disclosure::DisclosureType>::sse_encode(r#type, serializer);
            }
            crate::models::wallet_event::WalletEvent::Issuance { date_time, card } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(date_time, serializer);
                <crate::models::card::Card>::sse_encode(card, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::instruction::WalletInstructionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::instruction::WalletInstructionError::IncorrectPin {
                attempts_left_in_round,
                is_final_round,
            } => {
                <i32>::sse_encode(0, serializer);
                <u8>::sse_encode(attempts_left_in_round, serializer);
                <bool>::sse_encode(is_final_round, serializer);
            }
            crate::models::instruction::WalletInstructionError::Timeout { timeout_millis } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(timeout_millis, serializer);
            }
            crate::models::instruction::WalletInstructionError::Blocked => {
                <i32>::sse_encode(2, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::instruction::WalletInstructionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::instruction::WalletInstructionResult::Ok => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::instruction::WalletInstructionResult::InstructionError { error } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::instruction::WalletInstructionError>::sse_encode(error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.7.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
