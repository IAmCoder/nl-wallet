use std::sync::Arc;

use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::Serialize;
use tower_http::trace::TraceLayer;
use tracing::info;

use wallet_common::{
    account::{
        messages::{
            auth::{Certificate, Challenge, Registration},
            instructions::{
                CheckPin, GenerateKey, GenerateKeyResult, Instruction, InstructionChallengeRequestMessage,
                InstructionEndpoint, InstructionResultMessage, Sign, SignResult,
            },
        },
        serialization::DerVerifyingKey,
        signed::SignedChallengeResponse,
    },
    keys::EcdsaKey,
};

use crate::{errors::WalletProviderError, router_state::RouterState};

/// All handlers should return this result. The [`WalletProviderError`] wraps
/// a [`StatusCode`] and JSON body, all top-level errors should be convertible
/// to this type.
///
/// For any errors there are generated by `axum` before we get to the handlers
/// this custom error will not be used however. In this case `axum` will return
/// the appropriate HTTP response codes within the 4xx range and the body will
/// contain a plain text string instead. Since this amounts to programmer error
/// and this is not a public API, having error responses in that do not contain
/// the custom JSON body in those cases is acceptable. The client should still
/// be able to handle these errors appropriately.
type Result<T> = std::result::Result<T, WalletProviderError>;

pub fn router(router_state: RouterState) -> Router {
    let state = Arc::new(router_state);
    Router::new()
        .nest("/", health_router())
        .nest(
            "/api/v1",
            Router::new()
                .route("/enroll", post(enroll))
                .route("/createwallet", post(create_wallet))
                .route("/instructions/challenge", post(instruction_challenge))
                .route(&format!("/instructions/{}", CheckPin::ENDPOINT), post(check_pin))
                .route(&format!("/instructions/{}", GenerateKey::ENDPOINT), post(generate_key))
                .route(&format!("/instructions/{}", Sign::ENDPOINT), post(sign))
                .layer(TraceLayer::new_for_http())
                .with_state(Arc::clone(&state)),
        )
        .nest(
            "/config",
            Router::new()
                .route("/public-keys", get(public_keys))
                .layer(TraceLayer::new_for_http())
                .with_state(Arc::clone(&state)),
        )
}

fn health_router() -> Router {
    Router::new().route("/health", get(|| async {}))
}

async fn enroll(State(state): State<Arc<RouterState>>) -> Result<(StatusCode, Json<Challenge>)> {
    info!("Received enroll request, creating registration challenge");

    let challenge = state
        .account_server
        .registration_challenge(&state.certificate_signing_key)
        .await?;

    let body = Challenge { challenge };

    info!("Replying with registration challenge");

    Ok((StatusCode::OK, body.into()))
}

async fn create_wallet(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<SignedChallengeResponse<Registration>>,
) -> Result<(StatusCode, Json<Certificate>)> {
    info!("Received create wallet request, registering with account server");

    let cert = state
        .account_server
        .register(
            &state.certificate_signing_key,
            state.as_ref(),
            &state.repositories,
            &state.hsm,
            payload,
        )
        .await?;

    let body = Certificate { certificate: cert };

    info!("Replying with the created wallet certificate");

    Ok((StatusCode::CREATED, body.into()))
}

async fn instruction_challenge(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<InstructionChallengeRequestMessage>,
) -> Result<(StatusCode, Json<Challenge>)> {
    info!("Received challenge request, creating challenge");

    let challenge = state
        .account_server
        .instruction_challenge(payload, &state.repositories, state.as_ref(), &state.hsm)
        .await?;

    let body = Challenge { challenge };

    info!("Replying with the created challenge");

    Ok((StatusCode::OK, body.into()))
}

async fn check_pin(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<Instruction<CheckPin>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<()>>)> {
    info!("Received check pin request, handling the CheckPin instruction");
    let body = state.handle_instruction(payload).await?;
    Ok((StatusCode::OK, body.into()))
}

async fn generate_key(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<Instruction<GenerateKey>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<GenerateKeyResult>>)> {
    info!("Received generate key request, handling the GenerateKey instruction");
    let body = state.handle_instruction(payload).await?;
    Ok((StatusCode::OK, body.into()))
}

async fn sign(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<Instruction<Sign>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<SignResult>>)> {
    info!("Received sign request, handling the SignRequest instruction");
    let body = state.handle_instruction(payload).await?;
    Ok((StatusCode::OK, body.into()))
}

#[derive(Serialize)]
struct PublicKeys {
    certificate_public_key: DerVerifyingKey,
    instruction_result_public_key: DerVerifyingKey,
}

async fn public_keys(State(state): State<Arc<RouterState>>) -> Result<(StatusCode, Json<PublicKeys>)> {
    let certificate_public_key = state.certificate_signing_key.verifying_key().await?.into();
    let instruction_result_public_key = state.instruction_result_signing_key.verifying_key().await?.into();

    let body = PublicKeys {
        certificate_public_key,
        instruction_result_public_key,
    };

    Ok((StatusCode::OK, body.into()))
}
