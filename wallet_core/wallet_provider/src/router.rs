use std::sync::Arc;

use axum::{
    extract::State,
    http::StatusCode,
    response::{IntoResponse, Json, Response},
    routing::{get, post},
    Router,
};
use etag::EntityTag;
use http::{header, HeaderMap, HeaderValue};
use tower_http::trace::TraceLayer;
use tracing::{debug, info};

use wallet_common::{
    account::{
        messages::{
            auth::{Certificate, Challenge, Registration},
            instructions::{
                CheckPin, GenerateKey, GenerateKeyResult, Instruction, InstructionChallengeRequestMessage,
                InstructionEndpoint, InstructionResultMessage, Sign, SignResult,
            },
        },
        signed::SignedDouble,
    },
    config::wallet_config::WalletConfiguration,
};

use crate::{errors::WalletProviderError, router_state::RouterState};

/// All handlers should return this result. The [`WalletProviderError`] wraps
/// a [`StatusCode`] and JSON body, all top-level errors should be convertable
/// to this type.
///
/// For any errors there are generated by `axum` before we get to the handlers
/// this custom error will not be used however. In this case `axum` will return
/// the appropriate HTTP response codes within the 4xx range and the body will
/// contain a plain text string instead. Since this ammounts to programmer error
/// and this is not a public API, having error responses in that do not contain
/// the custom JSON body in those cases is acceptable. The client should still
/// be able to handle these errors appropriately.
type Result<T> = std::result::Result<T, WalletProviderError>;

pub fn router(router_state: RouterState, wallet_config: WalletConfiguration) -> Router {
    Router::new()
        .nest("/", health_router())
        .nest(
            "/api/v1",
            Router::new()
                .route("/enroll", post(enroll))
                .route("/createwallet", post(create_wallet))
                .route("/instructions/challenge", post(instruction_challenge))
                .route(&format!("/instructions/{}", CheckPin::ENDPOINT), post(check_pin))
                .route(&format!("/instructions/{}", GenerateKey::ENDPOINT), post(generate_key))
                .route(&format!("/instructions/{}", Sign::ENDPOINT), post(sign))
                .layer(TraceLayer::new_for_http())
                .with_state(Arc::new(router_state)),
        )
        .nest(
            "/config/v1",
            Router::new()
                .route("/wallet-config", get(configuration))
                .with_state(wallet_config),
        )
}

fn health_router() -> Router {
    Router::new().route("/health", get(|| async {}))
}

async fn enroll(State(state): State<Arc<RouterState>>) -> Result<(StatusCode, Json<Challenge>)> {
    info!("Received enroll request, creating registration challenge");

    let challenge = state
        .account_server
        .registration_challenge(&state.certificate_signing_key)
        .await?;

    let body = Challenge {
        challenge: challenge.into(),
    };

    info!("Replying with registration challenge");

    Ok((StatusCode::OK, body.into()))
}

async fn create_wallet(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<SignedDouble<Registration>>,
) -> Result<(StatusCode, Json<Certificate>)> {
    info!("Received create wallet request, registering with account server");

    let cert = state
        .account_server
        .register(
            &state.certificate_signing_key,
            state.as_ref(),
            &state.repositories,
            &state.hsm,
            payload,
        )
        .await?;

    let body = Certificate { certificate: cert };

    info!("Replying with the created wallet certificate");

    Ok((StatusCode::CREATED, body.into()))
}

async fn instruction_challenge(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<InstructionChallengeRequestMessage>,
) -> Result<(StatusCode, Json<Challenge>)> {
    info!("Received challenge request, creating challenge");

    let challenge = state
        .account_server
        .instruction_challenge(payload, &state.repositories, state.as_ref(), &state.hsm)
        .await?;

    let body = Challenge {
        challenge: challenge.into(),
    };

    info!("Replying with the created challenge");

    Ok((StatusCode::OK, body.into()))
}

async fn check_pin(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<Instruction<CheckPin>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<()>>)> {
    info!("Received check pin request, handling the CheckPin instruction");
    let body = state.handle_instruction(payload).await?;
    Ok((StatusCode::OK, body.into()))
}

async fn generate_key(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<Instruction<GenerateKey>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<GenerateKeyResult>>)> {
    info!("Received generate key request, handling the GenerateKey instruction");
    let body = state.handle_instruction(payload).await?;
    Ok((StatusCode::OK, body.into()))
}

async fn sign(
    State(state): State<Arc<RouterState>>,
    Json(payload): Json<Instruction<Sign>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<SignResult>>)> {
    info!("Received sign request, handling the SignRequest instruction");
    let body = state.handle_instruction(payload).await?;
    Ok((StatusCode::OK, body.into()))
}

async fn configuration(
    State(config): State<WalletConfiguration>,
    headers: HeaderMap,
) -> std::result::Result<Response, StatusCode> {
    info!("Received configuration request");

    let config_entity_tag: EntityTag = (&config).into();

    if let Some(etag) = headers.get(header::IF_NONE_MATCH) {
        let entity_tag = etag
            .to_str()
            .ok()
            .and_then(|etag| etag.parse().ok())
            .ok_or(StatusCode::BAD_REQUEST)?;

        // Comparing etags using the If-None-Match header uses the weak comparison algorithm.
        if config_entity_tag.weak_eq(&entity_tag) {
            debug!("Configuration is not modified");
            return Err(StatusCode::NOT_MODIFIED);
        }
    }

    let mut resp: Response = Json(config).into_response();
    resp.headers_mut().append(
        header::ETAG,
        // We can safely unwrap here because we know for sure there are no non-ascii characters used.
        HeaderValue::from_str(&config_entity_tag.to_string()).unwrap(),
    );

    info!("Replying with the configuration");
    Ok(resp)
}
