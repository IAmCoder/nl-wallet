use derive_more::AsRef;
use derive_more::From;
use derive_more::Into;
use serde::Deserialize;
use serde::Serialize;

/// A newtype around `Vec<u8>` that represent an assertion generated by Apple AppAttest.
/// It is to be treated as opaque bytes until received by the server.
#[derive(Debug, Clone, From, Into, AsRef, Serialize, Deserialize)]
pub struct AppleAssertion(Vec<u8>);

/// Trait for an Apple attested key. Note that [`SecureEcdsaKey`] is not
/// a supertrait, since signing does not produce an ECDSA signature.
pub trait AppleAttestedKey {
    type Error: std::error::Error + Send + Sync + 'static;

    /// Generate an Apple assertion using the attested key, which returns the [`AppleAssertion`] newtype.
    async fn sign(&self, payload: Vec<u8>) -> Result<AppleAssertion, Self::Error>;
}

#[cfg(any(test, feature = "mock_apple_attested_key"))]
pub use mock_apple_attested_key::MockAppleAttestedKey;

#[cfg(any(test, feature = "mock_apple_attested_key"))]
mod mock_apple_attested_key {
    use std::convert::Infallible;

    use p256::ecdsa::SigningKey;
    use p256::ecdsa::VerifyingKey;
    use rand_core::OsRng;

    use apple_app_attest::AppIdentifier;
    use apple_app_attest::Assertion;
    use apple_app_attest::Attestation;
    use apple_app_attest::MockAttestationCa;

    use super::AppleAssertion;
    use super::AppleAttestedKey;

    pub struct MockAppleAttestedKey {
        pub signing_key: SigningKey,
        pub app_identifier: AppIdentifier,
        pub counter: u32,
    }

    impl MockAppleAttestedKey {
        fn new(signing_key: SigningKey, app_identifier: AppIdentifier) -> Self {
            Self {
                signing_key,
                app_identifier,
                counter: 1,
            }
        }

        pub fn new_random(app_identifier: AppIdentifier) -> Self {
            Self::new(SigningKey::random(&mut OsRng), app_identifier)
        }

        pub fn new_with_attestation(
            app_identifier: AppIdentifier,
            challenge: &[u8],
        ) -> (Self, Vec<u8>, MockAttestationCa) {
            let mock_ca = Attestation::generate_ca();
            let (attestation, signing_key) = Attestation::new_mock_bytes(&mock_ca, challenge, &app_identifier);
            let attested_key = Self::new(signing_key, app_identifier);

            (attested_key, attestation, mock_ca)
        }

        pub fn verifying_key(&self) -> &VerifyingKey {
            self.signing_key.verifying_key()
        }
    }

    impl AppleAttestedKey for MockAppleAttestedKey {
        type Error = Infallible;

        async fn sign(&self, payload: Vec<u8>) -> Result<AppleAssertion, Self::Error> {
            let assertion_bytes =
                Assertion::new_mock_bytes(&self.signing_key, &self.app_identifier, self.counter, &payload);

            Ok(assertion_bytes.into())
        }
    }
}
