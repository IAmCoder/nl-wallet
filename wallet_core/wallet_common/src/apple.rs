use derive_more::AsRef;
use derive_more::From;
use derive_more::Into;
use serde::Deserialize;
use serde::Serialize;

/// A newtype around `Vec<u8>` that represent an assertion generated by Apple AppAttest.
/// It is to be treated as opaque bytes until received by the server.
#[derive(Debug, Clone, From, Into, AsRef, Serialize, Deserialize)]
pub struct AppleAssertion(Vec<u8>);

/// Trait for an Apple attested key. Note that [`SecureEcdsaKey`] is not
/// a supertrait, since signing does not produce an ECDSA signature.
pub trait AppleAttestedKey {
    type Error: std::error::Error + Send + Sync + 'static;

    /// Generate an Apple assertion using the attested key, which returns the [`AppleAssertion`] newtype.
    async fn sign(&self, payload: Vec<u8>) -> Result<AppleAssertion, Self::Error>;
}

#[cfg(any(test, feature = "mock_apple_attested_key"))]
pub use mock_apple_attested_key::MockAppleAttestedKey;

#[cfg(any(test, feature = "mock_apple_attested_key"))]
mod mock_apple_attested_key {
    use std::convert::Infallible;
    use std::sync::atomic::AtomicU32;
    use std::sync::atomic::Ordering;

    use p256::ecdsa::SigningKey;
    use p256::ecdsa::VerifyingKey;
    use rand_core::OsRng;

    use apple_app_attest::AppIdentifier;
    use apple_app_attest::Assertion;
    use apple_app_attest::Attestation;
    use apple_app_attest::MockAttestationCa;

    use super::AppleAssertion;
    use super::AppleAttestedKey;

    #[derive(Debug)]
    pub struct MockAppleAttestedKey {
        pub signing_key: SigningKey,
        pub app_identifier: AppIdentifier,
        pub next_counter: AtomicU32,
    }

    impl MockAppleAttestedKey {
        fn new(signing_key: SigningKey, app_identifier: AppIdentifier) -> Self {
            Self {
                signing_key,
                app_identifier,
                next_counter: AtomicU32::new(1),
            }
        }

        pub fn new_random(app_identifier: AppIdentifier) -> Self {
            Self::new(SigningKey::random(&mut OsRng), app_identifier)
        }

        pub fn new_with_attestation(
            mock_ca: &MockAttestationCa,
            app_identifier: AppIdentifier,
            challenge: &[u8],
        ) -> (Self, Vec<u8>) {
            let (attestation, signing_key) = Attestation::new_mock_bytes(mock_ca, challenge, &app_identifier);
            let attested_key = Self::new(signing_key, app_identifier);

            (attested_key, attestation)
        }

        pub fn verifying_key(&self) -> &VerifyingKey {
            self.signing_key.verifying_key()
        }

        pub fn next_counter(&self) -> u32 {
            self.next_counter.load(Ordering::Relaxed)
        }
    }

    impl AppleAttestedKey for MockAppleAttestedKey {
        type Error = Infallible;

        async fn sign(&self, payload: Vec<u8>) -> Result<AppleAssertion, Self::Error> {
            let assertion_bytes = Assertion::new_mock_bytes(
                &self.signing_key,
                &self.app_identifier,
                self.next_counter.fetch_add(1, Ordering::Relaxed),
                &payload,
            );

            Ok(assertion_bytes.into())
        }
    }
}
