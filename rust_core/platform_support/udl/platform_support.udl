// hw_keystore module

// Error type returned from native code
[Error]
interface KeyStoreError {
    KeyError(string reason); // All exceptions in native code are represented by this error
    BridgingError(string reason); // Reserved for UnexpectedUniFFICallbackError
};

// This represents the actual private ECDSA key stored in hardware.
// The identifier represents a string uniquely identifying the ECDSA key.
// This key will lazily be created on first use.
callback interface SigningKeyBridge {
    [Throws=KeyStoreError]
    sequence<u8> public_key(string identifier); // The public key in DER encoding

    [Throws=KeyStoreError]
    sequence<u8> sign(string identifier, sequence<u8> payload); // Returns a DER encoded signature
};

// This represents the actual private Symmetric key stored in hardware.
// The identifier represents a string uniquely identifying the key.
// This key will lazily be created on first use.
// On iOS this is within the same namespace as the ECDSA key above,
// on Android it is a separate key.
callback interface EncryptionKeyBridge {
    [Throws=KeyStoreError]
    sequence<u8> encrypt(string identifier, sequence<u8> payload); // Returns encrypted payload

    [Throws=KeyStoreError]
    sequence<u8> decrypt(string identifier, sequence<u8> payload); // Returns decrypted payload
};

// utils module

[Error]
interface UtilitiesError {
    PlatformError(string reason); // All exceptions in native code are represented by this error
    BridgingError(string reason); // Reserved for UnexpectedUniFFICallbackError
};

callback interface UtilitiesBridge {
    [Throws=UtilitiesError]
    string get_storage_path();
};

namespace platform_support {
    // Initialization function, this MUST be called by native code
    // so that Rust is able to use the bridge callbacks
    void init_platform_support(SigningKeyBridge signing_key, EncryptionKeyBridge encryption_key, UtilitiesBridge utils);
};
